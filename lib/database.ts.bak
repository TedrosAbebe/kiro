import sqlite3 from 'sqlite3';
sqlite3.verbose();
import { join } from 'path';
import bcrypt from 'bcryptjs';

const dbPath = join(process.cwd(), 'data', 'broker.db');
const db = new sqlite3.Database(dbPath, (err) => {
  if (err) {
    console.error('Failed to connect to the database:', err);
  } else {
    console.log('[lib/database] Initialized local SQLite database at', dbPath);
  }
});

// Enable foreign keys
db.run('PRAGMA foreign_keys = ON');

// Initialize database tables
export function initializeDatabase() {
  db.serialize(() => {
    db.run(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        role TEXT CHECK(role IN ('admin', 'broker', 'user')) DEFAULT 'user',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS properties (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        description TEXT,
        price REAL NOT NULL,
        currency TEXT DEFAULT 'ETB',
        city TEXT NOT NULL,
        area TEXT NOT NULL,
        latitude REAL,
        longitude REAL,
        type TEXT CHECK(type IN ('house_sale', 'house_rent', 'apartment', 'land')) NOT NULL,
        bedrooms INTEGER,
        bathrooms INTEGER,
        size REAL NOT NULL,
        features TEXT,
        status TEXT CHECK(status IN ('pending_payment', 'pending', 'approved', 'sold', 'rejected')) DEFAULT 'pending_payment',
        owner_id TEXT NOT NULL,
        broker_id TEXT,
        whatsapp_number TEXT NOT NULL,
        phone_number TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (owner_id) REFERENCES users (id),
        FOREIGN KEY (broker_id) REFERENCES users (id)
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS property_images (
        id TEXT PRIMARY KEY,
        property_id TEXT NOT NULL,
        image_url TEXT NOT NULL,
        is_primary BOOLEAN DEFAULT FALSE,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (property_id) REFERENCES properties (id) ON DELETE CASCADE
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS favorites (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        property_id TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, property_id),
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (property_id) REFERENCES properties (id) ON DELETE CASCADE
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS payments (
        id TEXT PRIMARY KEY,
        property_id TEXT NOT NULL,
        user_id TEXT NOT NULL,
        amount REAL NOT NULL,
        currency TEXT DEFAULT 'ETB',
        payment_type TEXT CHECK(payment_type IN ('rent_listing', 'sale_listing')) NOT NULL,
        status TEXT CHECK(status IN ('pending', 'confirmed', 'rejected')) DEFAULT 'pending',
        whatsapp_confirmation_message TEXT,

        admin_notes TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        confirmed_at DATETIME,
        FOREIGN KEY (property_id) REFERENCES properties (id),
        FOREIGN KEY (user_id) REFERENCES users (id)
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS whatsapp_confirmations (
        id TEXT PRIMARY KEY,
        payment_id TEXT NOT NULL,
        sender_number TEXT NOT NULL,
        message_content TEXT NOT NULL,
        received_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        processed BOOLEAN DEFAULT FALSE,
        FOREIGN KEY (payment_id) REFERENCES payments (id)
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS admin_logs (
        id TEXT PRIMARY KEY,
        admin_id TEXT NOT NULL,
        action TEXT NOT NULL,
        target_type TEXT CHECK(target_type IN ('user', 'property', 'payment', 'system')) NOT NULL,
        target_id TEXT,
        details TEXT,
        ip_address TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (admin_id) REFERENCES users (id)
      )
    `);

    db.run(`
      CREATE TABLE IF NOT EXISTS system_settings (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Insert default system settings
    const insertSetting = db.prepare(`
      INSERT OR IGNORE INTO system_settings (key, value) VALUES (?, ?)
    `);
    
    insertSetting.run('rent_listing_fee', '25');
    insertSetting.run('sale_listing_fee', '50');
    insertSetting.run('whatsapp_contact_placeholder', 'WHATSAPP_CONTACT_PLACEHOLDER');


    // Create default admin user
    createDefaultAdmin();
  });
}

function createDefaultAdmin() {
  // Check if default admin exists in users table
  const existingAdmin = db.prepare('SELECT id FROM users WHERE username = ? LIMIT 1').get('admin');
  
  if (!existingAdmin) {
    // Create new admin account
    console.log('üîê Setting up default admin account...');
    
    const adminPassword = 'admin123';
    const hashedPassword = bcrypt.hashSync(adminPassword, 12);
    const adminId = 'admin-' + Date.now();
    
    // Create in users table with username-based authentication
    db.prepare(`
      INSERT INTO users (id, username, password_hash, role)
      VALUES (?, ?, ?, ?)
    `).run(
      adminId,
      'admin',
      hashedPassword,
      'admin'
    );
    
    console.log('‚úÖ Default admin account created:');
    console.log('   Username: admin');
    console.log('   Password: admin123');
    console.log('   Role: admin');
  } else {
    console.log('‚úÖ Default admin account already exists');
  }
}

// Removed admin operations and OTP operations - using single users table now

// User operations (for both admin and regular users)
export const userOperations = {
  create: db.prepare(`
    INSERT INTO users (id, username, password_hash, role)
    VALUES (?, ?, ?, ?)
  `),
  
  findByUsername: db.prepare('SELECT * FROM users WHERE username = ?'),
  findById: db.prepare('SELECT * FROM users WHERE id = ?'),
  
  updateLastLogin: db.prepare(`
    UPDATE users SET updated_at = CURRENT_TIMESTAMP WHERE id = ?
  `),
  
  getAll: db.prepare('SELECT * FROM users ORDER BY created_at DESC'),
  
  updateRole: db.prepare('UPDATE users SET role = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?'),
  
  update: db.prepare(`
    UPDATE users 
    SET username = ?, role = ?, updated_at = CURRENT_TIMESTAMP 
    WHERE id = ?
  `),
  
  delete: db.prepare('DELETE FROM users WHERE id = ?'),
  
  getStats: db.prepare(`
    SELECT 
      role,
      COUNT(*) as count
    FROM users 
    GROUP BY role
  `)
}

// Property operations
export const propertyOperations = {
  create: db.prepare(`
    INSERT INTO properties (
      id, title, description, price, currency, city, area, latitude, longitude,
      type, bedrooms, bathrooms, size, features, owner_id, whatsapp_number, phone_number
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `),
  
  findById: db.prepare('SELECT * FROM properties WHERE id = ?'),
  
  getAll: db.prepare(`
    SELECT p.*, u.username as owner_name 
    FROM properties p 
    LEFT JOIN users u ON p.owner_id = u.id 
    ORDER BY p.created_at DESC
  `),
  
  getApproved: db.prepare(`
    SELECT p.*, u.username as owner_name 
    FROM properties p 
    LEFT JOIN users u ON p.owner_id = u.id 
    WHERE p.status = 'approved'
    ORDER BY p.created_at DESC
  `),
  
  getByOwner: db.prepare(`
    SELECT * FROM properties WHERE owner_id = ? ORDER BY created_at DESC
  `),
  
  updateStatus: db.prepare('UPDATE properties SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?'),
  
  search: db.prepare(`
    SELECT p.*, u.username as owner_name 
    FROM properties p 
    LEFT JOIN users u ON p.owner_id = u.id 
    WHERE p.status = 'approved' 
    AND (p.title LIKE ? OR p.city LIKE ? OR p.area LIKE ?)
    ORDER BY p.created_at DESC
  `),
  
  filter: db.prepare(`
    SELECT p.*, u.username as owner_name 
    FROM properties p 
    LEFT JOIN users u ON p.owner_id = u.id 
    WHERE p.status = 'approved'
    AND (? IS NULL OR p.type = ?)
    AND (? IS NULL OR p.city = ?)
    AND (? IS NULL OR p.price >= ?)
    AND (? IS NULL OR p.price <= ?)
    AND (? IS NULL OR p.bedrooms >= ?)
    AND (? IS NULL OR p.bathrooms >= ?)
    ORDER BY p.created_at DESC
  `),
  
  update: db.prepare(`
    UPDATE properties 
    SET title = ?, description = ?, price = ?, currency = ?, city = ?, area = ?, 
        type = ?, bedrooms = ?, bathrooms = ?, size = ?, features = ?, 
        whatsapp_number = ?, phone_number = ?, updated_at = CURRENT_TIMESTAMP
    WHERE id = ?
  `),
  
  delete: db.prepare('DELETE FROM properties WHERE id = ?'),
  
  getStats: db.prepare(`
    SELECT 
      status,
      COUNT(*) as count,
      AVG(price) as avg_price
    FROM properties 
    GROUP BY status
  `),
  
  getByStatus: db.prepare(`
    SELECT p.*, u.username as owner_name 
    FROM properties p 
    LEFT JOIN users u ON p.owner_id = u.id 
    WHERE p.status = ?
    ORDER BY p.created_at DESC
  `)
}

// Payment operations
export const paymentOperations = {
  create: db.prepare(`
    INSERT INTO payments (id, property_id, user_id, amount, payment_type)
    VALUES (?, ?, ?, ?, ?)
  `),
  
  findById: db.prepare('SELECT * FROM payments WHERE id = ?'),
  
  findByProperty: db.prepare('SELECT * FROM payments WHERE property_id = ?'),
  
  getPending: db.prepare(`
    SELECT p.*, pr.title as property_title, u.username as user_name, u.username as user_phone
    FROM payments p
    LEFT JOIN properties pr ON p.property_id = pr.id
    LEFT JOIN users u ON p.user_id = u.id
    WHERE p.status = 'pending'
    ORDER BY p.created_at DESC
  `),
  
  updateStatus: db.prepare(`
    UPDATE payments 
    SET status = ?, admin_notes = ?, confirmed_at = CASE WHEN ? = 'confirmed' THEN CURRENT_TIMESTAMP ELSE confirmed_at END
    WHERE id = ?
  `),
  
  getByUser: db.prepare(`
    SELECT p.*, pr.title as property_title
    FROM payments p
    LEFT JOIN properties pr ON p.property_id = pr.id
    WHERE p.user_id = ?
    ORDER BY p.created_at DESC
  `),
  
  getAll: db.prepare(`
    SELECT p.*, pr.title as property_title, u.username as user_name, u.username as user_phone
    FROM payments p
    LEFT JOIN properties pr ON p.property_id = pr.id
    LEFT JOIN users u ON p.user_id = u.id
    ORDER BY p.created_at DESC
  `),
  
  getStats: db.prepare(`
    SELECT 
      status,
      COUNT(*) as count,
      SUM(amount) as total_amount
    FROM payments 
    GROUP BY status
  `)
}

// Favorite operations
export const favoriteOperations = {
  add: db.prepare(`
    INSERT OR IGNORE INTO favorites (id, user_id, property_id)
    VALUES (?, ?, ?)
  `),
  
  remove: db.prepare('DELETE FROM favorites WHERE user_id = ? AND property_id = ?'),
  
  getByUser: db.prepare(`
    SELECT p.*, u.username as owner_name, f.created_at as favorited_at
    FROM favorites f
    JOIN properties p ON f.property_id = p.id
    LEFT JOIN users u ON p.owner_id = u.id
    WHERE f.user_id = ?
    ORDER BY f.created_at DESC
  `),
  
  checkExists: db.prepare('SELECT id FROM favorites WHERE user_id = ? AND property_id = ? LIMIT 1')
}

// Property image operations
export const imageOperations = {
  add: db.prepare(`
    INSERT INTO property_images (id, property_id, image_url, is_primary)
    VALUES (?, ?, ?, ?)
  `),
  
  getByProperty: db.prepare('SELECT * FROM property_images WHERE property_id = ? ORDER BY is_primary DESC, created_at ASC'),
  
  delete: db.prepare('DELETE FROM property_images WHERE id = ?'),
  
  setPrimary: db.prepare(`
    UPDATE property_images 
    SET is_primary = CASE WHEN id = ? THEN TRUE ELSE FALSE END 
    WHERE property_id = ?
  `)
}

// System settings operations
export const settingsOperations = {
  get: db.prepare('SELECT value FROM system_settings WHERE key = ?'),
  set: db.prepare('INSERT OR REPLACE INTO system_settings (key, value, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)'),
  getAll: db.prepare('SELECT * FROM system_settings ORDER BY key')
}

// WhatsApp confirmation operations
export const whatsappOperations = {
  addConfirmation: db.prepare(`
    INSERT INTO whatsapp_confirmations (id, payment_id, sender_number, message_content)
    VALUES (?, ?, ?, ?)
  `),
  
  getPending: db.prepare(`
    SELECT w.*, p.amount, p.payment_type, pr.title as property_title, u.username as user_name
    FROM whatsapp_confirmations w
    LEFT JOIN payments p ON w.payment_id = p.id
    LEFT JOIN properties pr ON p.property_id = pr.id
    LEFT JOIN users u ON p.user_id = u.id
    WHERE w.processed = FALSE
    ORDER BY w.received_at DESC
  `),
  
  markProcessed: db.prepare('UPDATE whatsapp_confirmations SET processed = TRUE WHERE id = ?')
}

// Admin log operations
export const adminLogOperations = {
  create: db.prepare(`
    INSERT INTO admin_logs (id, admin_id, action, target_type, target_id, details, ip_address)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `),
  
  getAll: db.prepare(`
    SELECT al.id, al.admin_id, al.action, al.target_type, al.target_id, al.details, al.ip_address, al.created_at, u.username as admin_name
    FROM admin_logs al
    LEFT JOIN users u ON al.admin_id = u.id
    ORDER BY al.created_at DESC
    LIMIT ?
  `),
  
  getByAdmin: db.prepare(`
    SELECT al.id, al.admin_id, al.action, al.target_type, al.target_id, al.details, al.ip_address, al.created_at, u.username as admin_name
    FROM admin_logs al
    LEFT JOIN users u ON al.admin_id = u.id
    WHERE al.admin_id = ?
    ORDER BY al.created_at DESC
    LIMIT ?
  `),
  
  getByTarget: db.prepare(`
    SELECT al.id, al.admin_id, al.action, al.target_type, al.target_id, al.details, al.ip_address, al.created_at, u.username as admin_name
    FROM admin_logs al
    LEFT JOIN users u ON al.admin_id = u.id
    WHERE al.target_type = ? AND al.target_id = ?
    ORDER BY al.created_at DESC
  `)
}

// Initialize database on import (with error handling)
try {
  initializeDatabase();
  console.log('‚úÖ Database initialized successfully');
} catch (error) {
  console.error('‚ùå Database initialization failed:', error.message);
  console.error('‚ùå This may cause API errors');
}

export default db